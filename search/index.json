[{"content":"1.注册事件（绑定事件） 1.1 注册事件概述 给元素添加事件，称为注册事件或者绑定事件。\r注册事件有两种方式：传统方式和方法监听注册方式\r传统注册方式 利用 on 开头的事件 onclick 1 2 \u0026lt;button onclick=“alert(\u0026#39;hi~\u0026#39;)”\u0026gt;\u0026lt;/button\u0026gt; btn.onclick = function() {} 特点： 注册事件的**唯一性**\r同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数\r方法监听注册方式 W3C 标准 推荐方式\raddEventListener() 它是一个方法\rIE9 之前的 IE 不支持此方法，可使用 attachEvent() 代替\r特点：同一个元素同一个事件可以注册多个监听器\r按注册顺序依次执行\r1.2 addEventListener 事件监听方式 1 eventTarget.addEventListener(type, listener[, useCapture]) eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。\r该方法接收三个参数： type：事件类型字符串，比如 click 、mouseover ，注意这里不要带 on listener：事件处理函数，事件发生时，会调用该监听函数 useCapture：可选参数，是一个布尔值，默认是 false。学完 DOM 事件流后，我们再进一步学习\n1.3 attachEvent 事件监听方式 1 eventTarget.attachEvent(eventNameWithOn, callback) eventTarget.attachEvent()方法将指定的监听器注册到 eventTarget（目标对象） 上，当该对象触发指定的事件时，指定的回调函数就会被执行。\r该方法接收两个参数： eventNameWithOn：事件类型字符串，比如 onclick 、onmouseover ，这里要带 on callback： 事件处理函数，当目标触发事件时回调函数被调用 注意：IE8 及早期版本支持\n1.4 注册事件兼容性解决方案 1 2 3 4 5 6 7 8 9 10 function addEventListener(element, eventName, fn) { // 判断当前浏览器是否支持 addEventListener 方法 if (element.addEventListener) { element.addEventListener(eventName, fn); // 第三个参数 默认是false } else if (element.attachEvent) { element.attachEvent(\u0026#39;on\u0026#39; + eventName, fn); } else { // 相当于 element.onclick = fn; element[\u0026#39;on\u0026#39; + eventName] = fn; } 兼容性处理的原则： 首先照顾大多数浏览器，再处理特殊浏览器\n2.删除事件（解绑时间） 2.1 删除事件的方式 2.1.1 传统注册方式 1 eventTarget.onclick = null; 2.1.2 方法监听注册事件 1 2 eventTarget.removeEventListener(type, listener[, useCapture]); eventTarget.detachEvent(eventNameWithOn, callback); 2.2 删除事件兼容性解决方案 1 2 3 4 5 6 7 8 9 function removeEventListener(element, eventName, fn) { // 判断当前浏览器是否支持 removeEventListener 方法 if (element.removeEventListener) { element.removeEventListener(eventName, fn); // 第三个参数 默认是false } else if (element.detachEvent) { element.detachEvent(\u0026#39;on\u0026#39; + eventName, fn); } else { element[\u0026#39;on\u0026#39; + eventName] = null; } 3. DOM事件流 事件流描述的是从页面中接收事件的顺序。\r事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM 事件流。\r比如我们给一个div 注册了点击事件：\nDOM 事件流分为3个阶段：\n捕获阶段 当前目标阶段 冒泡阶段 **事件冒泡：** IE 最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点的过程。\r**事件捕获：** 网景最早提出，由 DOM 最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。 我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（ 最具体元素）之后漂浮到水面上，这个过程相当于事件冒泡。\r事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM 事件流。\r注意 1、JS 代码中只能执行捕获或者冒泡其中的一个阶段。 2、onclick 和 attachEvent 只能得到冒泡阶段。 3、addEventListener(type, listener[, useCapture])第三个参数如果是 true，表示在事件捕获阶段调用事件处理程序；如果是 false（不写默认就是false），表示在事件冒泡阶段调用事件处理程序。 4、实际开发中我们很少使用事件捕获，我们更关注事件冒泡。 5、有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave 6、事件冒泡有时候会带来麻烦，有时候又会帮助很巧妙的做某些事件，我们后面讲解。\n4.事件对象 4.1 什么是事件对象 1 2 3 eventTarget.onclick = function(event) {} eventTarget.addEventListener(\u0026#39;click\u0026#39;, function(event) {}） // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt 官方解释：event 对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态。\r简单理解：事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象 event，它有很多属性和方法。\r比如：\n谁绑定了这个事件。 鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。 键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。 4.2 事件对象的使用语法 1 2 3 4 5 6 eventTarget.onclick = function(event) { // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt } eventTarget.addEventListener(\u0026#39;click\u0026#39;, function(event) { // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt }） 这个 event 是个形参，系统帮我们设定为事件对象，不需要传递实参过去。\r当我们注册事件时， event 对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数）。\n4.3 事件对象的兼容性方案 事件对象本身的获取存在兼容问题：\n标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e 就可以获取到。\n在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找。\n解决: e = e || window.event;\n4.4 事件对象的常见属性和方法 e.target 和 this 的区别：\nthis 是事件绑定的元素， 这个函数的调用者（绑定这个事件的元素） e.target 是事件触发的元素。\r!\n5. 阻止事件冒泡 5.1 阻止事件冒泡的两种方式 事件冒泡：开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点。\r事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握。\r阻止事件冒泡\n标准写法：利用事件对象里面的 stopPropagation()方法\n1 e.stopPropagation() 非标准写法：IE 6-8 利用事件对象 cancelBubble 属性\n1 e.cancelBubble = true; 5.2 阻止事件冒泡的兼容性解决方案 1 2 3 4 5 if(e \u0026amp;\u0026amp; e.stopPropagation){ e.stopPropagation(); }else{ window.event.cancelBubble = true; } 6. 事件委托（代理、委派） 事件委托 事件委托也称为事件代理， 在 jQuery 里面称为事件委派。\n事件委托的原理 不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点。 以上案例：给 ul 注册点击事件，然后利用事件对象的 target 来找到当前点击的 li，因为点击 li，事件会冒泡到 ul 上， ul 有注册事件，就会触发事件监听器。\n事件委托的作用 我们只操作了一次 DOM ，提高了程序的性能。\n","date":"2022-09-30T20:18:16+08:00","permalink":"https://example.com/post/js%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7-note/","title":"JS事件高级-note"},{"content":"","date":"2022-09-08T10:20:36+08:00","permalink":"https://example.com/post/demo2/","title":"Demo2"},{"content":"​\n1. nodemon nodemon 是一种工具，可在检测到目录中的文件更改时通过自动重新启动节点应用程序来帮助开发基于 node.js 的应用程序。\n安装 全局安装 1 $ npm i -g nodemon 本地安装 1 $ npm i -D nodemon 注意：本地安装需要在 package.json 文件的 script 脚本中指定要需要执行的命令\n1 2 3 4 5 { \u0026#34;script\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;nodemon app.js\u0026#34; } } ","date":"2022-09-02T16:42:16+08:00","permalink":"https://example.com/post/node/","title":"npm安装nodemon命令"}]